name: Contributor Credits

on:
  issues:
    types: [labeled, unlabeled]
  pull_request_target:
    types: [labeled, unlabeled]

jobs:
  update-credits:
    if: github.event.label.name == 'helpful contribution'
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: write
      issues: write
      pull-requests: write
    concurrency:
      group: credits-update
      cancel-in-progress: false

    steps:
      - name: Checkout credit branch
        uses: actions/checkout@v4
        with:
          ref: credit

      - name: Update credits data
        id: update
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const action = context.payload.action;
            // Handle both issues and pull requests
            const item = context.payload.issue || context.payload.pull_request;
            const username = item.user.login;
            const itemNumber = item.number;
            const isPR = !!context.payload.pull_request;

            // Read or initialize credits.json
            let data;
            try {
              data = JSON.parse(fs.readFileSync('credits.json', 'utf8'));
            } catch {
              data = { contributors: [] };
            }

            // Determine which list to use (issues or pull_requests)
            const listKey = isPR ? 'pull_requests' : 'issues';
            const itemType = isPR ? 'PR' : 'Issue';

            if (action === 'labeled') {
              // Find or create contributor entry
              let contributor = data.contributors.find(c => c.username === username);
              if (!contributor) {
                contributor = { username, issues: [], pull_requests: [] };
                data.contributors.push(contributor);
              }

              // Ensure both arrays exist (for backwards compatibility)
              if (!contributor.issues) contributor.issues = [];
              if (!contributor.pull_requests) contributor.pull_requests = [];

              // Idempotency: skip if item already credited
              if (contributor[listKey].some(i => i.number === itemNumber)) {
                console.log(`${itemType} #${itemNumber} already credited for @${username}, skipping.`);
                core.setOutput('changed', 'false');
                return;
              }

              contributor[listKey].push({
                number: itemNumber,
                title: item.title,
                labeled_at: new Date().toISOString()
              });
            } else if (action === 'unlabeled') {
              const contributor = data.contributors.find(c => c.username === username);
              if (!contributor) {
                console.log(`No credits entry for @${username}, skipping.`);
                core.setOutput('changed', 'false');
                return;
              }

              // Ensure both arrays exist
              if (!contributor.issues) contributor.issues = [];
              if (!contributor.pull_requests) contributor.pull_requests = [];

              const before = contributor[listKey].length;
              contributor[listKey] = contributor[listKey].filter(i => i.number !== itemNumber);

              if (contributor[listKey].length === before) {
                console.log(`${itemType} #${itemNumber} not found for @${username}, skipping.`);
                core.setOutput('changed', 'false');
                return;
              }

              // Remove contributor entirely if they have no remaining contributions
              if (contributor.issues.length === 0 && contributor.pull_requests.length === 0) {
                data.contributors = data.contributors.filter(c => c.username !== username);
              }
            }

            // Sort contributors by total contribution count descending
            data.contributors.sort((a, b) => {
              const aTotal = (a.issues?.length || 0) + (a.pull_requests?.length || 0);
              const bTotal = (b.issues?.length || 0) + (b.pull_requests?.length || 0);
              return bTotal - aTotal;
            });

            fs.writeFileSync('credits.json', JSON.stringify(data, null, 2) + '\n');
            core.setOutput('changed', 'true');

      - name: Commit to credit branch
        if: steps.update.outputs.changed == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add credits.json
          git diff --cached --quiet && echo "No changes to commit" && exit 0
          git commit -m "update contributor credits"
          git push

      - name: Trigger site redeployment and wait
        if: steps.update.outputs.changed == 'true' && github.event.action == 'labeled'
        uses: actions/github-script@v7
        with:
          script: |
            // Trigger the docs workflow via workflow_dispatch
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'docs.yml',
              ref: 'main'
            });

            const triggerTime = Date.now();
            await new Promise(r => setTimeout(r, 10000));

            // Poll until a successful deployment completes
            const deadline = Date.now() + 10 * 60 * 1000;
            while (Date.now() < deadline) {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'docs.yml',
                branch: 'main',
                per_page: 5,
                created: `>=${new Date(triggerTime - 30000).toISOString()}`
              });

              // Look for a completed successful run since we triggered
              const successful = runs.data.workflow_runs.find(
                r => r.status === 'completed' && r.conclusion === 'success'
              );
              if (successful) {
                console.log(`Docs workflow run #${successful.id} succeeded`);
                return;
              }

              const inProgress = runs.data.workflow_runs.find(
                r => r.status !== 'completed'
              );
              if (inProgress) {
                console.log(`Waiting for docs workflow run #${inProgress.id} (${inProgress.status})...`);
              } else if (runs.data.workflow_runs.length === 0) {
                console.log('No docs workflow runs found yet, waiting...');
              } else {
                console.log('No successful run yet, waiting for next attempt...');
              }

              await new Promise(r => setTimeout(r, 15000));
            }

            core.warning('Timed out waiting for docs deployment to complete');

      - name: Post thank-you comment
        if: steps.update.outputs.changed == 'true' && github.event.action == 'labeled'
        uses: actions/github-script@v7
        with:
          script: |
            const item = context.payload.issue || context.payload.pull_request;
            const author = item.user.login;
            const isPR = !!context.payload.pull_request;
            const itemType = isPR ? 'pull request' : 'issue';
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: item.number,
              body: `Thanks for the helpful contribution, @${author}! Your ${itemType} has been credited in our [contributors page](https://agent-of-empires.com/docs/credits.html). ðŸŽ‰`
            });
